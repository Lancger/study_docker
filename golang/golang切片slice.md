# 一、切片的创建和初始化

## 1、通过 make() 函数创建切片
```
使用 Golang 内置的 make() 函数创建切片，此时需要传入一个参数来指定切片的长度
// 创建一个整型切片
// 其长度和容量都是 5 个元素
slice := make([]int, 5)

此时只指定了切片的长度，那么切片的容量和长度相等。也可以分别指定长度和容量：
// 创建一个整型切片
// 其长度为 3 个元素，容量为 5 个元素
slice := make([]int, 3, 5)
分别指定长度和容量时，创建的切片，底层数组的长度是指定的容量，但是初始化后并不能访问所有的数组元素。
```

## 2、通过字面量创建切片
```
另一种常用的创建切片的方法是使用切片字面量，这种方法和创建数组类似，只是不需要指定[]运算符里的值。初始的长度和容量会基于初始化时提供的元素的个数确定：
// 创建字符串切片
// 其长度和容量都是 3 个元素
myStr := []string{"Jack", "Mark", "Nick"}

// 创建一个整型切片
// 其长度和容量都是 4 个元素
myNum := []int{10, 20, 30, 40}


当使用切片字面量创建切片时，还可以设置初始长度和容量。要做的就是在初始化时给出所需的长度和容量作为索引。下面的语法展示了如何使用索引方式创建长度和容量都是100个元素的切片：
// 创建字符串切片
// 使用空字符串初始化第 100 个元素
myStr := []string{99: ""}
```

## 3、区分数组的声明和切片的声明方式
```
当使用字面量来声明切片时，其语法与使用字面量声明数组非常相似。二者的区别是：如果在 [] 运算符里指定了一个值，那么创建的就是数组而不是切片。只有在 [] 中不指定值的时候，创建的才是切片。看下面的例子：

// 创建有 3 个元素的整型数组
myArray := [3]int{10, 20, 30}
// 创建长度和容量都是 3 的整型切片
mySlice := []int{10, 20, 30}
```

## 4、nil 和空切片
```
有时，程序可能需要声明一个值为 nil 的切片（也称nil切片）。只要在声明时不做任何初始化，就会创建一个 nil 切片

// 创建 nil 整型切片
var myNum []int

// 使用 make 创建空的整型切片
myNum := make([]int, 0)

// 使用切片字面量创建空的整型切片
myNum := []int{}

不管是使用 nil 切片还是空切片，对其调用内置函数 append()、len() 和 cap() 的效果都是一样的。
```

## 5、为切片中的元素赋值
```
对切片里某个索引指向的元素赋值和对数组里某个索引指向的元素赋值的方法完全一样。使用 [] 操作符就可以改变某个元素的值，下面是使用切片字面量来声明切片：

// 创建一个整型切片
// 其容量和长度都是 5 个元素
myNum := []int{10, 20, 30, 40, 50}

// 改变索引为 1 的元素的值
myNum [1] = 25

```

## 6、通过切片创建新的切片
```
切片之所以被称为切片，是因为创建一个新的切片，也就是把底层数组切出一部分。通过切片创建新切片的语法如下：

slice[i:j]
slice[i:j:k]

其中 i 表示从 slice 的第几个元素开始切，j 控制切片的长度(j-i)，k 控制切片的容量(k-i)，如果没有给定 k，则表示切到底层数组的最尾部。下面是几种常见的简写形式：

slice[i:]  // 从 i 切到最尾部
slice[:j]  // 从最开头切到 j(不包含 j)
slice[:]   // 从头切到尾，等价于复制整个 slice


```


参考文档：

https://www.jianshu.com/p/354fce23b4f0  Golang 入门 : 切片(slice)

https://www.cnblogs.com/sparkdev/tag/Golang/   golang基础
